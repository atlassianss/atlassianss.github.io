<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>kube-apiserver实现原理 | Hume</title><meta name="author" content="子非鱼"><meta name="copyright" content="子非鱼"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="在 kubernetes，可以从集群外部和内部两种方式访问 kubernetes API，在集群外直接访问 apiserver 提供的 API，在集群内即 pod 中可以通过访问 service 为 kubernetes 的 ClusterIP。kubernetes 集群在初始化完成后就会创建一个 kubernetes service，该 service 是 kube-apiserver 创建并进">
<meta property="og:type" content="article">
<meta property="og:title" content="kube-apiserver实现原理">
<meta property="og:url" content="https://github.com/2021/09/24/kube-apiserver%E4%B8%AD%20apiserver%20service%20%E7%9A%84%E5%AE%9E%E7%8E%B0/index.html">
<meta property="og:site_name" content="Hume">
<meta property="og:description" content="在 kubernetes，可以从集群外部和内部两种方式访问 kubernetes API，在集群外直接访问 apiserver 提供的 API，在集群内即 pod 中可以通过访问 service 为 kubernetes 的 ClusterIP。kubernetes 集群在初始化完成后就会创建一个 kubernetes service，该 service 是 kube-apiserver 创建并进">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://github.com/img/app8.jpg">
<meta property="article:published_time" content="2021-09-24T07:52:05.000Z">
<meta property="article:modified_time" content="2021-09-24T08:00:45.321Z">
<meta property="article:author" content="子非鱼">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/img/app8.jpg"><link rel="shortcut icon" href="/img/jpg.jpg"><link rel="canonical" href="https://github.com/2021/09/24/kube-apiserver%E4%B8%AD%20apiserver%20service%20%E7%9A%84%E5%AE%9E%E7%8E%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'kube-apiserver实现原理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-09-24 16:00:45'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Hume" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/ava.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">55</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">8</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/app8.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Hume</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">kube-apiserver实现原理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-09-24T07:52:05.000Z" title="Created 2021-09-24 15:52:05">2021-09-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-09-24T08:00:45.321Z" title="Updated 2021-09-24 16:00:45">2021-09-24</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="kube-apiserver实现原理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>在 kubernetes，可以从集群外部和内部两种方式访问 kubernetes API，在集群外直接访问 apiserver 提供的 API，在集群内即 pod 中可以通过访问 service 为 kubernetes 的 ClusterIP。kubernetes 集群在初始化完成后就会创建一个 kubernetes service，该 service 是 kube-apiserver 创建并进行维护的，如下所示：</p>
<p>| 1<br>2<br>3<br>4<br>5<br>6<br>7</p>
<p>| $ kubectl get service<br>NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE<br>kubernetes ClusterIP 10.96.0.1 <none> 443/TCP 4d22h</p>
<p>$ kubectl get endpoints kubernetes<br>NAME ENDPOINTS AGE<br>kubernetes 192.168.99.113:6443 4d22h</p>
<p>|  |<br>|  |</p>
<p>内置的 kubernetes service 无法删除，其 ClusterIP 为通过 –service-cluster-ip-range 参数指定的 ip 段中的首个 ip，kubernetes endpoints 中的 ip 以及 port 可以通过 –advertise-address 和 –secure-port 启动参数来指定。<br>kubernetes service 是由 kube-apiserver 中的 bootstrap controller 进行控制的，其主要以下几个功能：</p>
<ul>
<li>创建 kubernetes service；</li>
<li>创建 default、kube-system 和 kube-public 命名空间，如果启用了 NodeLease 特性还会创建 kube-node-lease 命名空间；</li>
<li>提供基于 Service ClusterIP 的修复及检查功能；</li>
<li>提供基于 Service NodePort 的修复及检查功能；</li>
</ul>
<p>kubernetes service 默认使用 ClusterIP 对外暴露服务，若要使用 nodePort 的方式可在 kube-apiserver 启动时通过 –kubernetes-service-node-port 参数指定对应的端口。</p>
<h3 id="bootstrap-controller-源码分析"><a href="#bootstrap-controller-源码分析" class="headerlink" title="bootstrap controller 源码分析"></a>bootstrap controller 源码分析</h3><p>kubernetes 版本：v1.16<br>bootstrap controller 的初始化以及启动是在 CreateKubeAPIServer 调用链的 InstallLegacyAPI 方法中完成的，bootstrap controller 的启停是由 apiserver 的 PostStartHook 和 ShutdownHook 进行控制的。<br>k8s.io/kubernetes/pkg/master/master.go:406</p>
<p>| 1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18</p>
<p>| func (m *Master) InstallLegacyAPI(……) error {<br>legacyRESTStorage, apiGroupInfo, err := legacyRESTStorageProvider.NewLegacyRESTStorage(restOptionsGetter)<br>if err != nil {<br>return fmt.Errorf(“Error building core storage: %v”, err)<br>}</p>
<pre><code>// 初始化 bootstrap-controller
controllerName := &quot;bootstrap-controller&quot;
coreClient := corev1client.NewForConfigOrDie(c.GenericConfig.LoopbackClientConfig)
bootstrapController := c.NewBootstrapController(......)
m.GenericAPIServer.AddPostStartHookOrDie(controllerName, bootstrapController.PostStartHook)
m.GenericAPIServer.AddPreShutdownHookOrDie(controllerName, bootstrapController.PreShutdownHook)

if err := m.GenericAPIServer.InstallLegacyAPIGroup(genericapiserver.DefaultLegacyAPIPrefix, &amp;apiGroupInfo); err != nil &#123;
    return fmt.Errorf(&quot;Error in registering group versions: %v&quot;, err)
&#125;
return nil
</code></pre>
<p>}</p>
<p>|  |<br>|  |</p>
<p>postStartHooks 会在 kube-apiserver 的启动方法 prepared.Run 中调用 RunPostStartHooks 启动所有 Hook。</p>
<h4 id="NewBootstrapController"><a href="#NewBootstrapController" class="headerlink" title="NewBootstrapController"></a>NewBootstrapController</h4><p>bootstrap controller 在初始化时需要设定多个参数，主要有 PublicIP、ServiceCIDR、PublicServicePort 等。PublicIP 是通过命令行参数 –advertise-address 指定的，如果没有指定，系统会自动选出一个 global IP。PublicServicePort 通过 –secure-port 启动参数来指定（默认为 6443），ServiceCIDR 通过 –service-cluster-ip-range 参数指定（默认为 10.0.0.0/24）。<br>k8s.io/kubernetes/pkg/master/controller.go:89</p>
<p>| 1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44</p>
<p>| func (c *completedConfig) NewBootstrapController(……) *Controller {<br>// 1、获取 PublicServicePort<br>_, publicServicePort, err := c.GenericConfig.SecureServing.HostPort()<br>if err != nil {<br>klog.Fatalf(“failed to get listener address: %v”, err)<br>}</p>
<pre><code>// 2、指定需要创建的 kube-system 和 kube-public
systemNamespaces := []string&#123;metav1.NamespaceSystem, metav1.NamespacePublic&#125;
if utilfeature.DefaultFeatureGate.Enabled(features.NodeLease) &#123;
    systemNamespaces = append(systemNamespaces, corev1.NamespaceNodeLease)
&#125;

return &amp;Controller&#123;
    ......
    // ServiceClusterIPRegistry 是在 CreateKubeAPIServer 初始化 RESTStorage 时初始化的，是一个 etcd 实例
    ServiceClusterIPRegistry:          legacyRESTStorage.ServiceClusterIPAllocator,
    ServiceClusterIPRange:             c.ExtraConfig.ServiceIPRange,
    SecondaryServiceClusterIPRegistry: legacyRESTStorage.SecondaryServiceClusterIPAllocator,

    // SecondaryServiceClusterIPRange 需要在启用 IPv6DualStack 后才能使用
    SecondaryServiceClusterIPRange:    c.ExtraConfig.SecondaryServiceIPRange,

    ServiceClusterIPInterval: 3 * time.Minute,

    ServiceNodePortRegistry: legacyRESTStorage.ServiceNodePortAllocator,
    ServiceNodePortRange:    c.ExtraConfig.ServiceNodePortRange,
    ServiceNodePortInterval: 3 * time.Minute,

    // API Server 绑定的IP，这个IP会作为kubernetes service的Endpoint的IP
    PublicIP: c.GenericConfig.PublicAddress,
    // 取 clusterIP range 中的第一个 IP
    ServiceIP:                 c.ExtraConfig.APIServerServiceIP,
    // 默认为 6443
    ServicePort:               c.ExtraConfig.APIServerServicePort,
    ExtraServicePorts:         c.ExtraConfig.ExtraServicePorts,
    ExtraEndpointPorts:        c.ExtraConfig.ExtraEndpointPorts,
    // 这里为 6443
    PublicServicePort:         publicServicePort,

    // 缺省是基于 ClusterIP 启动模式，这里为0
    KubernetesServiceNodePort: c.ExtraConfig.KubernetesServiceNodePort,
&#125;
</code></pre>
<p>}</p>
<p>|  |<br>|  |</p>
<p>自动选出 global IP 的代码如下所示：<br>k8s.io/kubernetes/staging/src/k8s.io/apimachinery/pkg/util/net/interface.go:323</p>
<p>| 1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11</p>
<p>| func ChooseHostInterface() (net.IP, error) {<br>var nw networkInterfacer = networkInterface{}<br>if _, err := os.Stat(ipv4RouteFile); os.IsNotExist(err) {<br>return chooseIPFromHostInterfaces(nw)<br>}<br>routes, err := getAllDefaultRoutes()<br>if err != nil {<br>return nil, err<br>}<br>return chooseHostInterfaceFromRoute(routes, nw)<br>}</p>
<p>|  |<br>|  |</p>
<h4 id="bootstrapController-Start"><a href="#bootstrapController-Start" class="headerlink" title="bootstrapController.Start"></a>bootstrapController.Start</h4><p>上文已经提到了 bootstrap controller 主要的四个功能：修复 ClusterIP、修复 NodePort、更新 kubernetes service、创建系统所需要的名字空间（default、kube-system、kube-public）。bootstrap controller 在启动后首先会完成一次 ClusterIP、NodePort 和 Kubernets 服务的处理，然后异步循环运行上面的 4 个工作。以下是其 start 方法：<br>k8s.io/kubernetes/pkg/master/controller.go:146</p>
<p>| 1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27</p>
<p>| func (c *Controller) Start() {<br>if c.runner != nil {<br>return<br>}</p>
<pre><code>// 1、首次启动时首先从 kubernetes endpoints 中移除自身的配置，
// 此时 kube-apiserver 可能处于非 ready 状态
endpointPorts := createEndpointPortSpec(c.PublicServicePort, &quot;https&quot;, c.ExtraEndpointPorts)
if err := c.EndpointReconciler.RemoveEndpoints(kubernetesServiceName, c.PublicIP, endpointPorts); err != nil &#123;
    klog.Errorf(&quot;Unable to remove old endpoints from kubernetes service: %v&quot;, err)
&#125;

// 2、初始化 repairClusterIPs 和 repairNodePorts 对象
repairClusterIPs := servicecontroller.NewRepair(......)
repairNodePorts := portallocatorcontroller.NewRepair(......)

// 3、首先运行一次 epairClusterIPs 和 repairNodePorts，即进行初始化
if err := repairClusterIPs.RunOnce(); err != nil &#123;
    klog.Fatalf(&quot;Unable to perform initial IP allocation check: %v&quot;, err)
&#125;
if err := repairNodePorts.RunOnce(); err != nil &#123;
    klog.Fatalf(&quot;Unable to perform initial service nodePort check: %v&quot;, err)
&#125;
// 4、定期执行 bootstrap controller 主要的四个功能
c.runner = async.NewRunner(c.RunKubernetesNamespaces, c.RunKubernetesService, repairClusterIPs.RunUntil, repairNodePorts.RunUntil)
c.runner.Start()
</code></pre>
<p>}</p>
<p>|  |<br>|  |</p>
<h4 id="c-RunKubernetesNamespaces"><a href="#c-RunKubernetesNamespaces" class="headerlink" title="c.RunKubernetesNamespaces"></a>c.RunKubernetesNamespaces</h4><p>c.RunKubernetesNamespaces 主要功能是创建 kube-system 和 kube-public 命名空间，如果启用了 NodeLease 特性功能还会创建 kube-node-lease 命名空间，之后每隔一分钟检查一次。<br>k8s.io/kubernetes/pkg/master/controller.go:199</p>
<p>| 1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9</p>
<p>| func (c *Controller) RunKubernetesNamespaces(ch chan struct{}) {<br>wait.Until(func() {<br>for _, ns := range c.SystemNamespaces {<br>if err := createNamespaceIfNeeded(c.NamespaceClient, ns); err != nil {<br>runtime.HandleError(fmt.Errorf(“unable to create required kubernetes system namespace %s: %v”, ns, err))<br>}<br>}<br>}, c.SystemNamespacesInterval, ch)<br>}</p>
<p>|  |<br>|  |</p>
<h4 id="c-RunKubernetesService"><a href="#c-RunKubernetesService" class="headerlink" title="c.RunKubernetesService"></a>c.RunKubernetesService</h4><p>c.RunKubernetesService 主要是检查 kubernetes service 是否处于正常状态，并定期执行同步操作。首先调用 /healthz 接口检查 apiserver 当前是否处于 ready 状态，若处于 ready 状态然后调用 c.UpdateKubernetesService 服务更新 kubernetes service 状态。<br>k8s.io/kubernetes/pkg/master/controller.go:210</p>
<p>| 1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13</p>
<p>| func (c <em>Controller) RunKubernetesService(ch chan struct{}) {<br>wait.PollImmediateUntil(100</em>time.Millisecond, func() (bool, error) {<br>var code int<br>c.healthClient.Get().AbsPath(“/healthz”).Do().StatusCode(&amp;code)<br>return code == http.StatusOK, nil<br>}, ch)</p>
<pre><code>wait.NonSlidingUntil(func() &#123;
    if err := c.UpdateKubernetesService(false); err != nil &#123;
        runtime.HandleError(fmt.Errorf(&quot;unable to sync kubernetes service: %v&quot;, err))
    &#125;
&#125;, c.EndpointInterval, ch)
</code></pre>
<p>}</p>
<p>|  |<br>|  |</p>
<h5 id="c-UpdateKubernetesService"><a href="#c-UpdateKubernetesService" class="headerlink" title="c.UpdateKubernetesService"></a>c.UpdateKubernetesService</h5><p>c.UpdateKubernetesService 的主要逻辑为：</p>
<ul>
<li>1、调用 createNamespaceIfNeeded 创建 default namespace；</li>
<li>2、调用 c.CreateOrUpdateMasterServiceIfNeeded 为 master 创建 kubernetes service；</li>
<li>3、调用 c.EndpointReconciler.ReconcileEndpoints 更新 master 的 endpoint；</li>
</ul>
<p>k8s.io/kubernetes/pkg/master/controller.go:230</p>
<p>| 1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15</p>
<p>| func (c *Controller) UpdateKubernetesService(reconcile bool) error {<br>if err := createNamespaceIfNeeded(c.NamespaceClient, metav1.NamespaceDefault); err != nil {<br>return err<br>}</p>
<pre><code>servicePorts, serviceType := createPortAndServiceSpec(c.ServicePort, c.PublicServicePort, c.KubernetesServiceNodePort, &quot;https&quot;, c.ExtraServicePorts)
if err := c.CreateOrUpdateMasterServiceIfNeeded(kubernetesServiceName, c.ServiceIP, servicePorts, serviceType, reconcile); err != nil &#123;
        return err
&#125;
endpointPorts := createEndpointPortSpec(c.PublicServicePort, &quot;https&quot;, c.ExtraEndpointPorts)
if err := c.EndpointReconciler.ReconcileEndpoints(kubernetesServiceName, c.PublicIP, endpointPorts, reconcile); err != nil &#123;
    return err
&#125;
return nil
</code></pre>
<p>}</p>
<p>|  |<br>|  |</p>
<h5 id="c-EndpointReconciler-ReconcileEndpoints"><a href="#c-EndpointReconciler-ReconcileEndpoints" class="headerlink" title="c.EndpointReconciler.ReconcileEndpoints"></a>c.EndpointReconciler.ReconcileEndpoints</h5><p>EndpointReconciler 的具体实现由 EndpointReconcilerType 决定，EndpointReconcilerType 是 –endpoint-reconciler-type 参数指定的，可选的参数有 master-count, lease, none，每种类型对应不同的 EndpointReconciler 实例，在 v1.16 中默认为 lease，此处仅分析 lease 对应的 EndpointReconciler 的实现。<br>一个集群中可能会有多个 apiserver 实例，因此需要统一管理 apiserver service 的 endpoints，c.EndpointReconciler.ReconcileEndpoints 就是用来管理 apiserver endpoints 的。一个集群中 apiserver 的所有实例会在 etcd 中的对应目录下创建 key，并定期更新这个 key 来上报自己的心跳信息，ReconcileEndpoints 会从 etcd 中获取 apiserver 的实例信息并更新 endpoint。<br>k8s.io/kubernetes/pkg/master/reconcilers/lease.go:144</p>
<p>| 1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77</p>
<p>| func (r *leaseEndpointReconciler) ReconcileEndpoints(……) error {<br>r.reconcilingLock.Lock()<br>defer r.reconcilingLock.Unlock()</p>
<pre><code>if r.stopReconcilingCalled &#123;
    return nil
&#125;

// 更新 lease 信息
if err := r.masterLeases.UpdateLease(ip.String()); err != nil &#123;
    return err
&#125;

return r.doReconcile(serviceName, endpointPorts, reconcilePorts)
</code></pre>
<p>}<br>func (r *leaseEndpointReconciler) doReconcile(……) error {<br>// 1、获取 master 的 endpoint<br>e, err := r.epAdapter.Get(corev1.NamespaceDefault, serviceName, metav1.GetOptions{})<br>shouldCreate := false<br>if err != nil {<br>if !errors.IsNotFound(err) {<br>return err<br>}</p>
<pre><code>    shouldCreate = true
    e = &amp;corev1.Endpoints&#123;
        ObjectMeta: metav1.ObjectMeta&#123;
            Name:      serviceName,
            Namespace: corev1.NamespaceDefault,
        &#125;,
    &#125;
&#125;

// 2、从 etcd 中获取所有的 master
masterIPs, err := r.masterLeases.ListLeases()
if err != nil &#123;
    return err
&#125;

if len(masterIPs) == 0 &#123;
    return fmt.Errorf(&quot;no master IPs were listed in storage, refusing to erase all endpoints for the kubernetes service&quot;)
&#125;

// 3、检查 endpoint 中 master 信息，如果与 etcd 中的不一致则进行更新
formatCorrect, ipCorrect, portsCorrect := checkEndpointSubsetFormatWithLease(e, masterIPs, endpointPorts, reconcilePorts)
if formatCorrect &amp;&amp; ipCorrect &amp;&amp; portsCorrect &#123;
    return nil
&#125;

if !formatCorrect &#123;
    e.Subsets = []corev1.EndpointSubset&#123;&#123;
            Addresses: []corev1.EndpointAddress&#123;&#125;,
            Ports:     endpointPorts,
        &#125;&#125;
&#125;
if !formatCorrect || !ipCorrect &#123;
    e.Subsets[0].Addresses = make([]corev1.EndpointAddress, len(masterIPs))
    for ind, ip := range masterIPs &#123;
        e.Subsets[0].Addresses[ind] = corev1.EndpointAddress&#123;IP: ip&#125;
    &#125;

    e.Subsets = endpointsv1.RepackSubsets(e.Subsets)
&#125;

if !portsCorrect &#123;
    e.Subsets[0].Ports = endpointPorts
&#125;

if shouldCreate &#123;
    if _, err = r.epAdapter.Create(corev1.NamespaceDefault, e); errors.IsAlreadyExists(err) &#123;
        err = nil
    &#125;
&#125; else &#123;
    _, err = r.epAdapter.Update(corev1.NamespaceDefault, e)
&#125;
return err
</code></pre>
<p>}</p>
<p>|  |<br>|  |</p>
<h4 id="repairClusterIPs-RunUntil"><a href="#repairClusterIPs-RunUntil" class="headerlink" title="repairClusterIPs.RunUntil"></a>repairClusterIPs.RunUntil</h4><p>repairClusterIP 主要解决的问题有：</p>
<ul>
<li>保证集群中所有的 ClusterIP 都是唯一分配的；</li>
<li>保证分配的 ClusterIP 不会超出指定范围；</li>
<li>确保已经分配给 service 但是因为 crash 等其他原因没有正确创建 ClusterIP；</li>
<li>自动将旧版本的 Kubernetes services 迁移到 ipallocator 原子性模型；</li>
</ul>
<p>repairClusterIPs.RunUntil 其实是调用 repairClusterIPs.runOnce 来处理的，其代码中的主要逻辑如下所示：<br>k8s.io/kubernetes/pkg/registry/core/service/ipallocator/controller/repair.go:134</p>
<p>| 1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80<br>81<br>82<br>83<br>84<br>85<br>86<br>87<br>88<br>89<br>90<br>91<br>92<br>93<br>94<br>95<br>96<br>97<br>98<br>99<br>100<br>101<br>102<br>103</p>
<p>| func (c *Repair) runOnce() error {<br>……</p>
<pre><code>// 1、首先从 etcd 中获取已经使用 ClusterIP 的快照
err = wait.PollImmediate(time.Second, 10*time.Second, func() (bool, error) &#123;
    var err error
    snapshot, err = c.alloc.Get()
    if err != nil &#123;
        return false, err
    &#125;

    if c.shouldWorkOnSecondary() &#123;
        secondarySnapshot, err = c.secondaryAlloc.Get()
        if err != nil &#123;
            return false, err
        &#125;
    &#125;
    return true, nil
&#125;)
if err != nil &#123;
    return fmt.Errorf(&quot;unable to refresh the service IP block: %v&quot;, err)
&#125;
// 2、判断 snapshot 是否已经初始化
if snapshot.Range == &quot;&quot; &#123;
    snapshot.Range = c.network.String()
&#125;

if c.shouldWorkOnSecondary() &amp;&amp; secondarySnapshot.Range == &quot;&quot; &#123;
    secondarySnapshot.Range = c.secondaryNetwork.String()
&#125;

stored, err = ipallocator.NewFromSnapshot(snapshot)
if c.shouldWorkOnSecondary() &#123;
    secondaryStored, secondaryErr = ipallocator.NewFromSnapshot(secondarySnapshot)
&#125;

if err != nil || secondaryErr != nil &#123;
    return fmt.Errorf(&quot;unable to rebuild allocator from snapshots: %v&quot;, err)
&#125;
// 3、获取 service list
list, err := c.serviceClient.Services(metav1.NamespaceAll).List(metav1.ListOptions&#123;&#125;)
if err != nil &#123;
    return fmt.Errorf(&quot;unable to refresh the service IP block: %v&quot;, err)
&#125;

// 4、将 CIDR 转换为对应的 IP range 格式
var rebuilt, secondaryRebuilt *ipallocator.Range
rebuilt, err = ipallocator.NewCIDRRange(c.network)

......

// 5、检查每个 Service 的 ClusterIP，保证其处于正常状态
for _, svc := range list.Items &#123;
    if !helper.IsServiceIPSet(&amp;svc) &#123;
        continue
    &#125;
    ip := net.ParseIP(svc.Spec.ClusterIP)
    ......

    actualAlloc := c.selectAllocForIP(ip, rebuilt, secondaryRebuilt)
    switch err := actualAlloc.Allocate(ip); err &#123;
    // 6、检查 ip 是否泄漏
    case nil:
        actualStored := c.selectAllocForIP(ip, stored, secondaryStored)
        if actualStored.Has(ip) &#123;
            actualStored.Release(ip)
        &#125; else &#123;
            ......
        &#125;
        delete(c.leaks, ip.String())
    // 7、ip 重复分配
    case ipallocator.ErrAllocated:
        ......
    // 8、ip 超出范围
    case err.(*ipallocator.ErrNotInRange):
        ......
    // 9、ip 已经分配完
    case ipallocator.ErrFull:
        ......
    default:
        ......
    &#125;
&#125;
// 10、对比是否有泄漏 ip
c.checkLeaked(stored, rebuilt)
if c.shouldWorkOnSecondary() &#123;
    c.checkLeaked(secondaryStored, secondaryRebuilt)
&#125;

// 11、更新快照
err = c.saveSnapShot(rebuilt, c.alloc, snapshot)
if err != nil &#123;
    return err
&#125;

if c.shouldWorkOnSecondary() &#123;
    err := c.saveSnapShot(secondaryRebuilt, c.secondaryAlloc, secondarySnapshot)
    if err != nil &#123;
        return nil
    &#125;
&#125;
return nil
</code></pre>
<p>}</p>
<p>|  |<br>|  |</p>
<h4 id="repairNodePorts-RunUnti"><a href="#repairNodePorts-RunUnti" class="headerlink" title="repairNodePorts.RunUnti"></a>repairNodePorts.RunUnti</h4><p>repairNodePorts 主要是用来纠正 service 中 nodePort 的信息，保证所有的 ports 都基于 cluster 创建的，当没有与 cluster 同步时会触发告警，其最终是调用 repairNodePorts.runOnce 进行处理的，主要逻辑与 ClusterIP 的处理逻辑类似。<br>k8s.io/kubernetes/pkg/registry/core/service/portallocator/controller/repair.go:84</p>
<p>| 1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80<br>81<br>82<br>83<br>84<br>85<br>86</p>
<p>| func (c <em>Repair) runOnce() error {<br>// 1、首先从 etcd 中获取已使用 nodeport 的快照<br>err := wait.PollImmediate(time.Second, 10</em>time.Second, func() (bool, error) {<br>var err error<br>snapshot, err = c.alloc.Get()<br>return err == nil, err<br>})<br>if err != nil {<br>return fmt.Errorf(“unable to refresh the port allocations: %v”, err)<br>}<br>// 2、检查 snapshot 是否初始化<br>if snapshot.Range == “” {<br>snapshot.Range = c.portRange.String()<br>}<br>// 3、获取已分配 nodePort 信息<br>stored, err := portallocator.NewFromSnapshot(snapshot)<br>if err != nil {<br>return fmt.Errorf(“unable to rebuild allocator from snapshot: %v”, err)<br>}<br>// 4、获取 service list<br>list, err := c.serviceClient.Services(metav1.NamespaceAll).List(metav1.ListOptions{})<br>if err != nil {<br>return fmt.Errorf(“unable to refresh the port block: %v”, err)<br>}</p>
<pre><code>rebuilt, err := portallocator.NewPortAllocator(c.portRange)
if err != nil &#123;
    return fmt.Errorf(&quot;unable to create port allocator: %v&quot;, err)
&#125;

// 5、检查每个 Service ClusterIP 的 port，保证其处于正常状态
for i := range list.Items &#123;
    svc := &amp;list.Items[i]
    ports := collectServiceNodePorts(svc)
    if len(ports) == 0 &#123;
        continue
    &#125;
    for _, port := range ports &#123;
        switch err := rebuilt.Allocate(port); err &#123;
        // 6、检查 port 是否泄漏
        case nil:
            if stored.Has(port) &#123;
                stored.Release(port)
            &#125; else &#123;
                ......
            &#125;
            delete(c.leaks, port)
        // 7、port 重复分配
        case portallocator.ErrAllocated:
            ......
        // 8、port 超出分配范围
        case err.(*portallocator.ErrNotInRange):
            ......
        // 9、port 已经分配完
        case portallocator.ErrFull:
            ......
        default:
            ......
        &#125;
    &#125;
&#125;
// 10、检查 port 是否泄漏
stored.ForEach(func(port int) &#123;
    count, found := c.leaks[port]
    switch &#123;
    case !found:
        ......
        count = numRepairsBeforeLeakCleanup - 1
        fallthrough
    case count &gt; 0:
        c.leaks[port] = count - 1
        if err := rebuilt.Allocate(port); err != nil &#123;
            runtime.HandleError(fmt.Errorf(&quot;the node port %d may have leaked, but can not be allocated: %v&quot;, port, err))
        &#125;
    default:
        ......
    &#125;
&#125;)

// 11、更新 snapshot
if err := rebuilt.Snapshot(snapshot); err != nil &#123;
    return fmt.Errorf(&quot;unable to snapshot the updated port allocations: %v&quot;, err)
&#125;
......
return nil
</code></pre>
<p>}</p>
<p>|  |<br>|  |</p>
<p>以上就是 bootstrap controller 的主要实现。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文主要分析了 kube-apiserver 中 apiserver service 的实现，apiserver service 是通过 bootstrap controller 控制的，bootstrap controller 会保证 apiserver service 以及其 endpoint 处于正常状态，需要注意的是，apiserver service 的 endpoint 根据启动时指定的参数分为三种控制方式，本文仅分析了 lease 的实现方式，如果使用 master-count 方式，需要将每个 master 实例的 port、apiserver-count 等配置参数改为一致。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">子非鱼</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://github.com/2021/09/24/kube-apiserver%E4%B8%AD%20apiserver%20service%20%E7%9A%84%E5%AE%9E%E7%8E%B0/">https://github.com/2021/09/24/kube-apiserver%E4%B8%AD%20apiserver%20service%20%E7%9A%84%E5%AE%9E%E7%8E%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/app8.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2021/09/24/zookeeper%E7%BC%96%E6%8E%92/"><img class="prev-cover" src="/img/default_cover3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">zookeeper编排</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/ava.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">子非鱼</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">55</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">8</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">10</div></a></div></div><a class="button--animated" id="card-info-btn" href="https://github.com/atlassianss"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">子非鱼安知鱼之乐，子非我安知我之乐</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#bootstrap-controller-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">bootstrap controller 源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#NewBootstrapController"><span class="toc-number">1.1.</span> <span class="toc-text">NewBootstrapController</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bootstrapController-Start"><span class="toc-number">1.2.</span> <span class="toc-text">bootstrapController.Start</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-RunKubernetesNamespaces"><span class="toc-number">1.3.</span> <span class="toc-text">c.RunKubernetesNamespaces</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-RunKubernetesService"><span class="toc-number">1.4.</span> <span class="toc-text">c.RunKubernetesService</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#c-UpdateKubernetesService"><span class="toc-number">1.4.1.</span> <span class="toc-text">c.UpdateKubernetesService</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#c-EndpointReconciler-ReconcileEndpoints"><span class="toc-number">1.4.2.</span> <span class="toc-text">c.EndpointReconciler.ReconcileEndpoints</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#repairClusterIPs-RunUntil"><span class="toc-number">1.5.</span> <span class="toc-text">repairClusterIPs.RunUntil</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#repairNodePorts-RunUnti"><span class="toc-number">1.6.</span> <span class="toc-text">repairNodePorts.RunUnti</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/09/29/ettercap%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/" title="ettercap内网渗透"><img src="/img/app2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ettercap内网渗透"/></a><div class="content"><a class="title" href="/2021/09/29/ettercap%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/" title="ettercap内网渗透">ettercap内网渗透</a><time datetime="2021-09-29T08:56:11.000Z" title="Created 2021-09-29 16:56:11">2021-09-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/09/29/wsl2%E5%AE%89%E8%A3%85kali-linux%E4%BB%A5%E5%8F%8A%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2kex/" title="wsl2安装kali linux以及图形界面kex"><img src="/img/app4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="wsl2安装kali linux以及图形界面kex"/></a><div class="content"><a class="title" href="/2021/09/29/wsl2%E5%AE%89%E8%A3%85kali-linux%E4%BB%A5%E5%8F%8A%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2kex/" title="wsl2安装kali linux以及图形界面kex">wsl2安装kali linux以及图形界面kex</a><time datetime="2021-09-29T08:44:43.000Z" title="Created 2021-09-29 16:44:43">2021-09-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/09/29/pi4%E5%AE%89%E8%A3%85kali-linux/" title="pi4安装kali linux"><img src="/img/app10.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="pi4安装kali linux"/></a><div class="content"><a class="title" href="/2021/09/29/pi4%E5%AE%89%E8%A3%85kali-linux/" title="pi4安装kali linux">pi4安装kali linux</a><time datetime="2021-09-29T06:01:45.000Z" title="Created 2021-09-29 14:01:45">2021-09-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/09/29/go%E8%AF%AD%E8%A8%80%E5%A4%A7%E7%BA%B2/" title="go语言大纲"><img src="/img/app7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="go语言大纲"/></a><div class="content"><a class="title" href="/2021/09/29/go%E8%AF%AD%E8%A8%80%E5%A4%A7%E7%BA%B2/" title="go语言大纲">go语言大纲</a><time datetime="2021-09-29T01:22:39.000Z" title="Created 2021-09-29 09:22:39">2021-09-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/09/28/kafka%E9%9B%86%E7%BE%A4%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE/" title="kafka集群核心配置"><img src="/img/app3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="kafka集群核心配置"/></a><div class="content"><a class="title" href="/2021/09/28/kafka%E9%9B%86%E7%BE%A4%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE/" title="kafka集群核心配置">kafka集群核心配置</a><time datetime="2021-09-28T14:57:58.000Z" title="Created 2021-09-28 22:57:58">2021-09-28</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 子非鱼</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>